/* tslint:disable */
/* eslint-disable */
/**
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  \'podman info\'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  \'podman pull quay.io/containers/podman\'  curl -XPOST --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman\'  \'podman list images\'  curl --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/libpod/images/json\' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Container,
  ContainerCreateResponse,
  ContainerJSON,
  ContainerTopOKBody,
  ContainerWait200Response,
  ContainersPruneReport,
  CreateContainerConfig,
  ErrorModel,
  UpdateConfig,
} from '../models/index';
import {
    ContainerFromJSON,
    ContainerToJSON,
    ContainerCreateResponseFromJSON,
    ContainerCreateResponseToJSON,
    ContainerJSONFromJSON,
    ContainerJSONToJSON,
    ContainerTopOKBodyFromJSON,
    ContainerTopOKBodyToJSON,
    ContainerWait200ResponseFromJSON,
    ContainerWait200ResponseToJSON,
    ContainersPruneReportFromJSON,
    ContainersPruneReportToJSON,
    CreateContainerConfigFromJSON,
    CreateContainerConfigToJSON,
    ErrorModelFromJSON,
    ErrorModelToJSON,
    UpdateConfigFromJSON,
    UpdateConfigToJSON,
} from '../models/index';

export interface ContainerArchiveRequest {
    name: string;
    path: string;
}

export interface ContainerArchiveLibpodRequest {
    name: string;
    path: string;
    rename?: string;
}

export interface ContainerAttachRequest {
    name: string;
    detachKeys?: string;
    logs?: boolean;
    stream?: boolean;
    stdout?: boolean;
    stderr?: boolean;
    stdin?: boolean;
}

export interface ContainerChangesLibpodRequest {
    name: string;
    parent?: string;
    diffType?: ContainerChangesLibpodDiffTypeEnum;
}

export interface ContainerCreateRequest {
    body: CreateContainerConfig;
    name?: string;
}

export interface ContainerDeleteRequest {
    name: string;
    force?: boolean;
    v?: boolean;
    link?: boolean;
}

export interface ContainerExportRequest {
    name: string;
}

export interface ContainerInspectRequest {
    name: string;
    size?: boolean;
}

export interface ContainerKillRequest {
    name: string;
    all?: boolean;
    signal?: string;
}

export interface ContainerListRequest {
    all?: boolean;
    external?: boolean;
    limit?: number;
    size?: boolean;
    filters?: string;
}

export interface ContainerLogsRequest {
    name: string;
    follow?: boolean;
    stdout?: boolean;
    stderr?: boolean;
    since?: string;
    until?: string;
    timestamps?: boolean;
    tail?: string;
}

export interface ContainerPauseRequest {
    name: string;
}

export interface ContainerPruneRequest {
    filters?: string;
}

export interface ContainerRenameRequest {
    name: string;
    name2: string;
}

export interface ContainerResizeRequest {
    name: string;
    h?: number;
    w?: number;
    running?: boolean;
}

export interface ContainerRestartRequest {
    name: string;
    t?: number;
}

export interface ContainerStartRequest {
    name: string;
    detachKeys?: string;
}

export interface ContainerStatsRequest {
    name: string;
    stream?: boolean;
    oneShot?: boolean;
}

export interface ContainerStopRequest {
    name: string;
    t?: number;
}

export interface ContainerTopRequest {
    name: string;
    psArgs?: string;
}

export interface ContainerUnpauseRequest {
    name: string;
}

export interface ContainerUpdateRequest {
    name: string;
    resources?: UpdateConfig;
}

export interface ContainerWaitRequest {
    name: string;
    condition?: string;
    interval?: string;
}

export interface ImageCommitRequest {
    container?: string;
    repo?: string;
    tag?: string;
    comment?: string;
    author?: string;
    pause?: boolean;
    changes?: string;
    squash?: boolean;
}

export interface PutContainerArchiveRequest {
    name: string;
    path: string;
    noOverwriteDirNonDir?: string;
    copyUIDGID?: string;
    request?: string;
}

/**
 * 
 */
export class ContainersCompatApi extends runtime.BaseAPI {

    /**
     * Get a tar archive of files from a container
     * Get files from a container
     */
    async containerArchiveRaw(requestParameters: ContainerArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerArchive().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling containerArchive().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/archive`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get a tar archive of files from a container
     * Get files from a container
     */
    async containerArchive(requestParameters: ContainerArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.containerArchiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Copy a tar archive of files from a container
     * Copy files from a container
     */
    async containerArchiveLibpodRaw(requestParameters: ContainerArchiveLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerArchiveLibpod().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling containerArchiveLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['rename'] != null) {
            queryParameters['rename'] = requestParameters['rename'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/archive`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Copy a tar archive of files from a container
     * Copy files from a container
     */
    async containerArchiveLibpod(requestParameters: ContainerArchiveLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.containerArchiveLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  It uses the same stream format as docker, see the libpod attach endpoint for a description of the format. 
     * Attach to a container
     */
    async containerAttachRaw(requestParameters: ContainerAttachRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerAttach().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['detachKeys'] != null) {
            queryParameters['detachKeys'] = requestParameters['detachKeys'];
        }

        if (requestParameters['logs'] != null) {
            queryParameters['logs'] = requestParameters['logs'];
        }

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['stdin'] != null) {
            queryParameters['stdin'] = requestParameters['stdin'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  It uses the same stream format as docker, see the libpod attach endpoint for a description of the format. 
     * Attach to a container
     */
    async containerAttach(requestParameters: ContainerAttachRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerAttachRaw(requestParameters, initOverrides);
    }

    /**
     * Returns which files in a container\'s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
     * Report on changes to container\'s filesystem; adds, deletes or modifications.
     */
    async containerChangesLibpodRaw(requestParameters: ContainerChangesLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerChangesLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['parent'] != null) {
            queryParameters['parent'] = requestParameters['parent'];
        }

        if (requestParameters['diffType'] != null) {
            queryParameters['diffType'] = requestParameters['diffType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/changes`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns which files in a container\'s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
     * Report on changes to container\'s filesystem; adds, deletes or modifications.
     */
    async containerChangesLibpod(requestParameters: ContainerChangesLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerChangesLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Create a container
     */
    async containerCreateRaw(requestParameters: ContainerCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContainerCreateResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling containerCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/containers/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateContainerConfigToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContainerCreateResponseFromJSON(jsonValue));
    }

    /**
     * Create a container
     */
    async containerCreate(requestParameters: ContainerCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContainerCreateResponse> {
        const response = await this.containerCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a container
     */
    async containerDeleteRaw(requestParameters: ContainerDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        if (requestParameters['v'] != null) {
            queryParameters['v'] = requestParameters['v'];
        }

        if (requestParameters['link'] != null) {
            queryParameters['link'] = requestParameters['link'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a container
     */
    async containerDelete(requestParameters: ContainerDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Export the contents of a container as a tarball.
     * Export a container
     */
    async containerExportRaw(requestParameters: ContainerExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerExport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/export`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Export the contents of a container as a tarball.
     * Export a container
     */
    async containerExport(requestParameters: ContainerExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerExportRaw(requestParameters, initOverrides);
    }

    /**
     * Return low-level information about a container.
     * Inspect container
     */
    async containerInspectRaw(requestParameters: ContainerInspectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContainerJSON>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerInspect().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContainerJSONFromJSON(jsonValue));
    }

    /**
     * Return low-level information about a container.
     * Inspect container
     */
    async containerInspect(requestParameters: ContainerInspectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContainerJSON> {
        const response = await this.containerInspectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Signal to send to the container as an integer or string (e.g. SIGINT)
     * Kill container
     */
    async containerKillRaw(requestParameters: ContainerKillRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerKill().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['signal'] != null) {
            queryParameters['signal'] = requestParameters['signal'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/kill`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Signal to send to the container as an integer or string (e.g. SIGINT)
     * Kill container
     */
    async containerKill(requestParameters: ContainerKillRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerKillRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of containers
     * List containers
     */
    async containerListRaw(requestParameters: ContainerListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Container>>> {
        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['external'] != null) {
            queryParameters['external'] = requestParameters['external'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContainerFromJSON));
    }

    /**
     * Returns a list of containers
     * List containers
     */
    async containerList(requestParameters: ContainerListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Container>> {
        const response = await this.containerListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get stdout and stderr logs from a container.
     * Get container logs
     */
    async containerLogsRaw(requestParameters: ContainerLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerLogs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['follow'] != null) {
            queryParameters['follow'] = requestParameters['follow'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        if (requestParameters['until'] != null) {
            queryParameters['until'] = requestParameters['until'];
        }

        if (requestParameters['timestamps'] != null) {
            queryParameters['timestamps'] = requestParameters['timestamps'];
        }

        if (requestParameters['tail'] != null) {
            queryParameters['tail'] = requestParameters['tail'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/logs`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get stdout and stderr logs from a container.
     * Get container logs
     */
    async containerLogs(requestParameters: ContainerLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerLogsRaw(requestParameters, initOverrides);
    }

    /**
     * Use the cgroups freezer to suspend all processes in a container.
     * Pause container
     */
    async containerPauseRaw(requestParameters: ContainerPauseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerPause().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/pause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use the cgroups freezer to suspend all processes in a container.
     * Pause container
     */
    async containerPause(requestParameters: ContainerPauseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerPauseRaw(requestParameters, initOverrides);
    }

    /**
     * Remove containers not in use
     * Delete stopped containers
     */
    async containerPruneRaw(requestParameters: ContainerPruneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContainersPruneReport>>> {
        const queryParameters: any = {};

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/prune`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContainersPruneReportFromJSON));
    }

    /**
     * Remove containers not in use
     * Delete stopped containers
     */
    async containerPrune(requestParameters: ContainerPruneRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContainersPruneReport>> {
        const response = await this.containerPruneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Change the name of an existing container.
     * Rename an existing container
     */
    async containerRenameRaw(requestParameters: ContainerRenameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerRename().'
            );
        }

        if (requestParameters['name2'] == null) {
            throw new runtime.RequiredError(
                'name2',
                'Required parameter "name2" was null or undefined when calling containerRename().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name2'] != null) {
            queryParameters['name'] = requestParameters['name2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/rename`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the name of an existing container.
     * Rename an existing container
     */
    async containerRename(requestParameters: ContainerRenameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerRenameRaw(requestParameters, initOverrides);
    }

    /**
     * Resize the terminal attached to a container (for use with Attach).
     * Resize a container\'s TTY
     */
    async containerResizeRaw(requestParameters: ContainerResizeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerResize().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['h'] != null) {
            queryParameters['h'] = requestParameters['h'];
        }

        if (requestParameters['w'] != null) {
            queryParameters['w'] = requestParameters['w'];
        }

        if (requestParameters['running'] != null) {
            queryParameters['running'] = requestParameters['running'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/resize`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Resize the terminal attached to a container (for use with Attach).
     * Resize a container\'s TTY
     */
    async containerResize(requestParameters: ContainerResizeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.containerResizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restart container
     */
    async containerRestartRaw(requestParameters: ContainerRestartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerRestart().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['t'] != null) {
            queryParameters['t'] = requestParameters['t'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/restart`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Restart container
     */
    async containerRestart(requestParameters: ContainerRestartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerRestartRaw(requestParameters, initOverrides);
    }

    /**
     * Start a container
     */
    async containerStartRaw(requestParameters: ContainerStartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerStart().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['detachKeys'] != null) {
            queryParameters['detachKeys'] = requestParameters['detachKeys'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/start`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Start a container
     */
    async containerStart(requestParameters: ContainerStartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerStartRaw(requestParameters, initOverrides);
    }

    /**
     * This returns a live stream of a containerâ€™s resource usage statistics.
     * Get stats for a container
     */
    async containerStatsRaw(requestParameters: ContainerStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerStats().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        if (requestParameters['oneShot'] != null) {
            queryParameters['one-shot'] = requestParameters['oneShot'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/stats`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This returns a live stream of a containerâ€™s resource usage statistics.
     * Get stats for a container
     */
    async containerStats(requestParameters: ContainerStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.containerStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stop a container
     * Stop a container
     */
    async containerStopRaw(requestParameters: ContainerStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerStop().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['t'] != null) {
            queryParameters['t'] = requestParameters['t'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/stop`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop a container
     * Stop a container
     */
    async containerStop(requestParameters: ContainerStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerStopRaw(requestParameters, initOverrides);
    }

    /**
     * List processes running inside a container
     */
    async containerTopRaw(requestParameters: ContainerTopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContainerTopOKBody>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerTop().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['psArgs'] != null) {
            queryParameters['ps_args'] = requestParameters['psArgs'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/top`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContainerTopOKBodyFromJSON(jsonValue));
    }

    /**
     * List processes running inside a container
     */
    async containerTop(requestParameters: ContainerTopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContainerTopOKBody> {
        const response = await this.containerTopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resume a paused container
     * Unpause container
     */
    async containerUnpauseRaw(requestParameters: ContainerUnpauseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerUnpause().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/unpause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resume a paused container
     * Unpause container
     */
    async containerUnpause(requestParameters: ContainerUnpauseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerUnpauseRaw(requestParameters, initOverrides);
    }

    /**
     * Change configuration settings for an existing container without requiring recreation.
     * Update configuration of an existing container
     */
    async containerUpdateRaw(requestParameters: ContainerUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/containers/{name}/update`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['resources'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change configuration settings for an existing container without requiring recreation.
     * Update configuration of an existing container
     */
    async containerUpdate(requestParameters: ContainerUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerUpdateRaw(requestParameters, initOverrides);
    }

    /**
     * Block until a container stops or given condition is met.
     * Wait on a container
     */
    async containerWaitRaw(requestParameters: ContainerWaitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContainerWait200Response>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerWait().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['condition'] != null) {
            queryParameters['condition'] = requestParameters['condition'];
        }

        if (requestParameters['interval'] != null) {
            queryParameters['interval'] = requestParameters['interval'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/containers/{name}/wait`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContainerWait200ResponseFromJSON(jsonValue));
    }

    /**
     * Block until a container stops or given condition is met.
     * Wait on a container
     */
    async containerWait(requestParameters: ContainerWaitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContainerWait200Response> {
        const response = await this.containerWaitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new image from a container
     * New Image
     */
    async imageCommitRaw(requestParameters: ImageCommitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['container'] != null) {
            queryParameters['container'] = requestParameters['container'];
        }

        if (requestParameters['repo'] != null) {
            queryParameters['repo'] = requestParameters['repo'];
        }

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        if (requestParameters['comment'] != null) {
            queryParameters['comment'] = requestParameters['comment'];
        }

        if (requestParameters['author'] != null) {
            queryParameters['author'] = requestParameters['author'];
        }

        if (requestParameters['pause'] != null) {
            queryParameters['pause'] = requestParameters['pause'];
        }

        if (requestParameters['changes'] != null) {
            queryParameters['changes'] = requestParameters['changes'];
        }

        if (requestParameters['squash'] != null) {
            queryParameters['squash'] = requestParameters['squash'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/commit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new image from a container
     * New Image
     */
    async imageCommit(requestParameters: ImageCommitRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageCommitRaw(requestParameters, initOverrides);
    }

    /**
     * Put a tar archive of files into a container
     * Put files into a container
     */
    async putContainerArchiveRaw(requestParameters: PutContainerArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling putContainerArchive().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling putContainerArchive().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['noOverwriteDirNonDir'] != null) {
            queryParameters['noOverwriteDirNonDir'] = requestParameters['noOverwriteDirNonDir'];
        }

        if (requestParameters['copyUIDGID'] != null) {
            queryParameters['copyUIDGID'] = requestParameters['copyUIDGID'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/containers/{name}/archive`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Put a tar archive of files into a container
     * Put files into a container
     */
    async putContainerArchive(requestParameters: PutContainerArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putContainerArchiveRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ContainerChangesLibpodDiffTypeEnum = {
    All: 'all',
    Container: 'container',
    Image: 'image'
} as const;
export type ContainerChangesLibpodDiffTypeEnum = typeof ContainerChangesLibpodDiffTypeEnum[keyof typeof ContainerChangesLibpodDiffTypeEnum];
