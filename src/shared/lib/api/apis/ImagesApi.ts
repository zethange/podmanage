/* tslint:disable */
/* eslint-disable */
/**
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  \'podman info\'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  \'podman pull quay.io/containers/podman\'  curl -XPOST --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman\'  \'podman list images\'  curl --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/libpod/images/json\' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorModel,
  HistoryResponse,
  ImageBuildLibpod200Response,
  ImageData,
  ImageImportReport,
  ImageLoadReport,
  ImageSearch200Response,
  ImageTreeReport,
  LibpodImageSummary,
  LibpodImagesPullReport,
  LibpodImagesRemoveReport,
  PruneReport,
  ScpReport,
} from '../models/index';
import {
    ErrorModelFromJSON,
    ErrorModelToJSON,
    HistoryResponseFromJSON,
    HistoryResponseToJSON,
    ImageBuildLibpod200ResponseFromJSON,
    ImageBuildLibpod200ResponseToJSON,
    ImageDataFromJSON,
    ImageDataToJSON,
    ImageImportReportFromJSON,
    ImageImportReportToJSON,
    ImageLoadReportFromJSON,
    ImageLoadReportToJSON,
    ImageSearch200ResponseFromJSON,
    ImageSearch200ResponseToJSON,
    ImageTreeReportFromJSON,
    ImageTreeReportToJSON,
    LibpodImageSummaryFromJSON,
    LibpodImageSummaryToJSON,
    LibpodImagesPullReportFromJSON,
    LibpodImagesPullReportToJSON,
    LibpodImagesRemoveReportFromJSON,
    LibpodImagesRemoveReportToJSON,
    PruneReportFromJSON,
    PruneReportToJSON,
    ScpReportFromJSON,
    ScpReportToJSON,
} from '../models/index';

export interface ImageBuildLibpodRequest {
    dockerfile?: string;
    t?: string;
    allplatforms?: boolean;
    extrahosts?: string;
    remote?: string;
    q?: boolean;
    nocache?: boolean;
    cachefrom?: string;
    pull?: boolean;
    rm?: boolean;
    forcerm?: boolean;
    memory?: number;
    memswap?: number;
    cpushares?: number;
    cpusetcpus?: string;
    cpuperiod?: number;
    cpuquota?: number;
    buildargs?: string;
    shmsize?: number;
    squash?: boolean;
    labels?: string;
    layerLabel?: Array<string>;
    layers?: boolean;
    networkmode?: string;
    platform?: string;
    target?: string;
    outputs?: string;
    httpproxy?: boolean;
    unsetenv?: Array<string>;
    unsetlabel?: Array<string>;
    volume?: Array<string>;
}

export interface ImageChangesLibpodRequest {
    name: string;
    parent?: string;
    diffType?: ImageChangesLibpodDiffTypeEnum;
}

export interface ImageDeleteAllLibpodRequest {
    images?: Array<string>;
    all?: boolean;
    force?: boolean;
    ignore?: boolean;
    lookupManifest?: boolean;
}

export interface ImageDeleteLibpodRequest {
    name: string;
    force?: boolean;
}

export interface ImageExistsLibpodRequest {
    name: string;
}

export interface ImageExportLibpodRequest {
    format?: string;
    references?: Array<string>;
    compress?: boolean;
    ociAcceptUncompressedLayers?: boolean;
}

export interface ImageGetLibpodRequest {
    name: string;
    format?: string;
    compress?: boolean;
}

export interface ImageHistoryLibpodRequest {
    name: string;
}

export interface ImageImportLibpodRequest {
    upload: Blob;
    contentType?: ImageImportLibpodContentTypeEnum;
    changes?: Array<string>;
    message?: string;
    reference?: string;
    url?: string;
}

export interface ImageInspectLibpodRequest {
    name: string;
}

export interface ImageListLibpodRequest {
    all?: boolean;
    filters?: string;
}

export interface ImageLoadLibpodRequest {
    upload: string;
}

export interface ImagePruneLibpodRequest {
    all?: boolean;
    external?: boolean;
    filters?: string;
}

export interface ImagePullLibpodRequest {
    reference?: string;
    quiet?: boolean;
    compatMode?: boolean;
    arch?: string;
    oS?: string;
    variant?: string;
    policy?: string;
    tlsVerify?: boolean;
    allTags?: boolean;
    xRegistryAuth?: string;
}

export interface ImagePushLibpodRequest {
    name: string;
    destination?: string;
    forceCompressionFormat?: boolean;
    tlsVerify?: boolean;
    quiet?: boolean;
    xRegistryAuth?: string;
}

export interface ImageResolveLibpodRequest {
    name: string;
}

export interface ImageScpLibpodRequest {
    name: string;
    destination?: string;
    quiet?: boolean;
}

export interface ImageSearchLibpodRequest {
    term?: string;
    limit?: number;
    filters?: string;
    tlsVerify?: boolean;
    listTags?: boolean;
}

export interface ImageTagLibpodRequest {
    name: string;
    repo?: string;
    tag?: string;
}

export interface ImageTreeLibpodRequest {
    name: string;
    whatrequires?: boolean;
}

export interface ImageUntagLibpodRequest {
    name: string;
    repo?: string;
    tag?: string;
}

/**
 * 
 */
export class ImagesApi extends runtime.BaseAPI {

    /**
     * Build an image from the given Dockerfile(s)
     * Create image
     */
    async imageBuildLibpodRaw(requestParameters: ImageBuildLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageBuildLibpod200Response>> {
        const queryParameters: any = {};

        if (requestParameters['dockerfile'] != null) {
            queryParameters['dockerfile'] = requestParameters['dockerfile'];
        }

        if (requestParameters['t'] != null) {
            queryParameters['t'] = requestParameters['t'];
        }

        if (requestParameters['allplatforms'] != null) {
            queryParameters['allplatforms'] = requestParameters['allplatforms'];
        }

        if (requestParameters['extrahosts'] != null) {
            queryParameters['extrahosts'] = requestParameters['extrahosts'];
        }

        if (requestParameters['remote'] != null) {
            queryParameters['remote'] = requestParameters['remote'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['nocache'] != null) {
            queryParameters['nocache'] = requestParameters['nocache'];
        }

        if (requestParameters['cachefrom'] != null) {
            queryParameters['cachefrom'] = requestParameters['cachefrom'];
        }

        if (requestParameters['pull'] != null) {
            queryParameters['pull'] = requestParameters['pull'];
        }

        if (requestParameters['rm'] != null) {
            queryParameters['rm'] = requestParameters['rm'];
        }

        if (requestParameters['forcerm'] != null) {
            queryParameters['forcerm'] = requestParameters['forcerm'];
        }

        if (requestParameters['memory'] != null) {
            queryParameters['memory'] = requestParameters['memory'];
        }

        if (requestParameters['memswap'] != null) {
            queryParameters['memswap'] = requestParameters['memswap'];
        }

        if (requestParameters['cpushares'] != null) {
            queryParameters['cpushares'] = requestParameters['cpushares'];
        }

        if (requestParameters['cpusetcpus'] != null) {
            queryParameters['cpusetcpus'] = requestParameters['cpusetcpus'];
        }

        if (requestParameters['cpuperiod'] != null) {
            queryParameters['cpuperiod'] = requestParameters['cpuperiod'];
        }

        if (requestParameters['cpuquota'] != null) {
            queryParameters['cpuquota'] = requestParameters['cpuquota'];
        }

        if (requestParameters['buildargs'] != null) {
            queryParameters['buildargs'] = requestParameters['buildargs'];
        }

        if (requestParameters['shmsize'] != null) {
            queryParameters['shmsize'] = requestParameters['shmsize'];
        }

        if (requestParameters['squash'] != null) {
            queryParameters['squash'] = requestParameters['squash'];
        }

        if (requestParameters['labels'] != null) {
            queryParameters['labels'] = requestParameters['labels'];
        }

        if (requestParameters['layerLabel'] != null) {
            queryParameters['layerLabel'] = requestParameters['layerLabel']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['layers'] != null) {
            queryParameters['layers'] = requestParameters['layers'];
        }

        if (requestParameters['networkmode'] != null) {
            queryParameters['networkmode'] = requestParameters['networkmode'];
        }

        if (requestParameters['platform'] != null) {
            queryParameters['platform'] = requestParameters['platform'];
        }

        if (requestParameters['target'] != null) {
            queryParameters['target'] = requestParameters['target'];
        }

        if (requestParameters['outputs'] != null) {
            queryParameters['outputs'] = requestParameters['outputs'];
        }

        if (requestParameters['httpproxy'] != null) {
            queryParameters['httpproxy'] = requestParameters['httpproxy'];
        }

        if (requestParameters['unsetenv'] != null) {
            queryParameters['unsetenv'] = requestParameters['unsetenv']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['unsetlabel'] != null) {
            queryParameters['unsetlabel'] = requestParameters['unsetlabel']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['volume'] != null) {
            queryParameters['volume'] = requestParameters['volume']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/build`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageBuildLibpod200ResponseFromJSON(jsonValue));
    }

    /**
     * Build an image from the given Dockerfile(s)
     * Create image
     */
    async imageBuildLibpod(requestParameters: ImageBuildLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageBuildLibpod200Response> {
        const response = await this.imageBuildLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns which files in an image\'s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
     * Report on changes to images\'s filesystem; adds, deletes or modifications.
     */
    async imageChangesLibpodRaw(requestParameters: ImageChangesLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageChangesLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['parent'] != null) {
            queryParameters['parent'] = requestParameters['parent'];
        }

        if (requestParameters['diffType'] != null) {
            queryParameters['diffType'] = requestParameters['diffType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/changes`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns which files in an image\'s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
     * Report on changes to images\'s filesystem; adds, deletes or modifications.
     */
    async imageChangesLibpod(requestParameters: ImageChangesLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageChangesLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Remove one or more images from the storage.
     * Remove one or more images from the storage.
     */
    async imageDeleteAllLibpodRaw(requestParameters: ImageDeleteAllLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibpodImagesRemoveReport>> {
        const queryParameters: any = {};

        if (requestParameters['images'] != null) {
            queryParameters['images'] = requestParameters['images']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        if (requestParameters['ignore'] != null) {
            queryParameters['ignore'] = requestParameters['ignore'];
        }

        if (requestParameters['lookupManifest'] != null) {
            queryParameters['lookupManifest'] = requestParameters['lookupManifest'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/remove`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibpodImagesRemoveReportFromJSON(jsonValue));
    }

    /**
     * Remove one or more images from the storage.
     * Remove one or more images from the storage.
     */
    async imageDeleteAllLibpod(requestParameters: ImageDeleteAllLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibpodImagesRemoveReport> {
        const response = await this.imageDeleteAllLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove an image from the local storage.
     * Remove an image from the local storage.
     */
    async imageDeleteLibpodRaw(requestParameters: ImageDeleteLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibpodImagesRemoveReport>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageDeleteLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibpodImagesRemoveReportFromJSON(jsonValue));
    }

    /**
     * Remove an image from the local storage.
     * Remove an image from the local storage.
     */
    async imageDeleteLibpod(requestParameters: ImageDeleteLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibpodImagesRemoveReport> {
        const response = await this.imageDeleteLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if image exists in local store
     * Image exists
     */
    async imageExistsLibpodRaw(requestParameters: ImageExistsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageExistsLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/exists`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check if image exists in local store
     * Image exists
     */
    async imageExistsLibpod(requestParameters: ImageExistsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageExistsLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Export multiple images into a single object. Only `docker-archive` is currently supported.
     * Export multiple images
     */
    async imageExportLibpodRaw(requestParameters: ImageExportLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['references'] != null) {
            queryParameters['references'] = requestParameters['references']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['compress'] != null) {
            queryParameters['compress'] = requestParameters['compress'];
        }

        if (requestParameters['ociAcceptUncompressedLayers'] != null) {
            queryParameters['ociAcceptUncompressedLayers'] = requestParameters['ociAcceptUncompressedLayers'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Export multiple images into a single object. Only `docker-archive` is currently supported.
     * Export multiple images
     */
    async imageExportLibpod(requestParameters: ImageExportLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.imageExportLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export an image
     * Export an image
     */
    async imageGetLibpodRaw(requestParameters: ImageGetLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageGetLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['compress'] != null) {
            queryParameters['compress'] = requestParameters['compress'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/get`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Export an image
     * Export an image
     */
    async imageGetLibpod(requestParameters: ImageGetLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.imageGetLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return parent layers of an image.
     * History of an image
     */
    async imageHistoryLibpodRaw(requestParameters: ImageHistoryLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HistoryResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageHistoryLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/history`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HistoryResponseFromJSON(jsonValue));
    }

    /**
     * Return parent layers of an image.
     * History of an image
     */
    async imageHistoryLibpod(requestParameters: ImageHistoryLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HistoryResponse> {
        const response = await this.imageHistoryLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Import a previously exported tarball as an image.
     * Import image
     */
    async imageImportLibpodRaw(requestParameters: ImageImportLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageImportReport>> {
        if (requestParameters['upload'] == null) {
            throw new runtime.RequiredError(
                'upload',
                'Required parameter "upload" was null or undefined when calling imageImportLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['changes'] != null) {
            queryParameters['changes'] = requestParameters['changes']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['message'] != null) {
            queryParameters['message'] = requestParameters['message'];
        }

        if (requestParameters['reference'] != null) {
            queryParameters['reference'] = requestParameters['reference'];
        }

        if (requestParameters['url'] != null) {
            queryParameters['url'] = requestParameters['url'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-tar';

        if (requestParameters['contentType'] != null) {
            headerParameters['Content-Type'] = String(requestParameters['contentType']);
        }

        const response = await this.request({
            path: `/libpod/images/import`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['upload'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageImportReportFromJSON(jsonValue));
    }

    /**
     * Import a previously exported tarball as an image.
     * Import image
     */
    async imageImportLibpod(requestParameters: ImageImportLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageImportReport> {
        const response = await this.imageImportLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Obtain low-level information about an image
     * Inspect an image
     */
    async imageInspectLibpodRaw(requestParameters: ImageInspectLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageData>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageInspectLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageDataFromJSON(jsonValue));
    }

    /**
     * Obtain low-level information about an image
     * Inspect an image
     */
    async imageInspectLibpod(requestParameters: ImageInspectLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageData> {
        const response = await this.imageInspectLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of images on the server
     * List Images
     */
    async imageListLibpodRaw(requestParameters: ImageListLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LibpodImageSummary>>> {
        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LibpodImageSummaryFromJSON));
    }

    /**
     * Returns a list of images on the server
     * List Images
     */
    async imageListLibpod(requestParameters: ImageListLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LibpodImageSummary>> {
        const response = await this.imageListLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load an image (oci-archive or docker-archive) stream.
     * Load image
     */
    async imageLoadLibpodRaw(requestParameters: ImageLoadLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageLoadReport>> {
        if (requestParameters['upload'] == null) {
            throw new runtime.RequiredError(
                'upload',
                'Required parameter "upload" was null or undefined when calling imageLoadLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-tar';

        const response = await this.request({
            path: `/libpod/images/load`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['upload'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageLoadReportFromJSON(jsonValue));
    }

    /**
     * Load an image (oci-archive or docker-archive) stream.
     * Load image
     */
    async imageLoadLibpod(requestParameters: ImageLoadLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageLoadReport> {
        const response = await this.imageLoadLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove images that are not being used by a container
     * Prune unused images
     */
    async imagePruneLibpodRaw(requestParameters: ImagePruneLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PruneReport>>> {
        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['external'] != null) {
            queryParameters['external'] = requestParameters['external'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/prune`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PruneReportFromJSON));
    }

    /**
     * Remove images that are not being used by a container
     * Prune unused images
     */
    async imagePruneLibpod(requestParameters: ImagePruneLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PruneReport>> {
        const response = await this.imagePruneLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pull one or more images from a container registry.
     * Pull images
     */
    async imagePullLibpodRaw(requestParameters: ImagePullLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibpodImagesPullReport>> {
        const queryParameters: any = {};

        if (requestParameters['reference'] != null) {
            queryParameters['reference'] = requestParameters['reference'];
        }

        if (requestParameters['quiet'] != null) {
            queryParameters['quiet'] = requestParameters['quiet'];
        }

        if (requestParameters['compatMode'] != null) {
            queryParameters['compatMode'] = requestParameters['compatMode'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['Arch'] = requestParameters['arch'];
        }

        if (requestParameters['oS'] != null) {
            queryParameters['OS'] = requestParameters['oS'];
        }

        if (requestParameters['variant'] != null) {
            queryParameters['Variant'] = requestParameters['variant'];
        }

        if (requestParameters['policy'] != null) {
            queryParameters['policy'] = requestParameters['policy'];
        }

        if (requestParameters['tlsVerify'] != null) {
            queryParameters['tlsVerify'] = requestParameters['tlsVerify'];
        }

        if (requestParameters['allTags'] != null) {
            queryParameters['allTags'] = requestParameters['allTags'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xRegistryAuth'] != null) {
            headerParameters['X-Registry-Auth'] = String(requestParameters['xRegistryAuth']);
        }

        const response = await this.request({
            path: `/libpod/images/pull`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibpodImagesPullReportFromJSON(jsonValue));
    }

    /**
     * Pull one or more images from a container registry.
     * Pull images
     */
    async imagePullLibpod(requestParameters: ImagePullLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibpodImagesPullReport> {
        const response = await this.imagePullLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Push an image to a container registry
     * Push Image
     */
    async imagePushLibpodRaw(requestParameters: ImagePushLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imagePushLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['destination'] != null) {
            queryParameters['destination'] = requestParameters['destination'];
        }

        if (requestParameters['forceCompressionFormat'] != null) {
            queryParameters['forceCompressionFormat'] = requestParameters['forceCompressionFormat'];
        }

        if (requestParameters['tlsVerify'] != null) {
            queryParameters['tlsVerify'] = requestParameters['tlsVerify'];
        }

        if (requestParameters['quiet'] != null) {
            queryParameters['quiet'] = requestParameters['quiet'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xRegistryAuth'] != null) {
            headerParameters['X-Registry-Auth'] = String(requestParameters['xRegistryAuth']);
        }

        const response = await this.request({
            path: `/libpod/images/{name}/push`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Push an image to a container registry
     * Push Image
     */
    async imagePushLibpod(requestParameters: ImagePushLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.imagePushLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resolve the passed image name to a list of fully-qualified images referring to container registries.
     * Resolve an image (short) name
     */
    async imageResolveLibpodRaw(requestParameters: ImageResolveLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageResolveLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/resolve`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resolve the passed image name to a list of fully-qualified images referring to container registries.
     * Resolve an image (short) name
     */
    async imageResolveLibpod(requestParameters: ImageResolveLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageResolveLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Copy an image from one host to another
     * Copy an image from one host to another
     */
    async imageScpLibpodRaw(requestParameters: ImageScpLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScpReport>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageScpLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['destination'] != null) {
            queryParameters['destination'] = requestParameters['destination'];
        }

        if (requestParameters['quiet'] != null) {
            queryParameters['quiet'] = requestParameters['quiet'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/scp/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScpReportFromJSON(jsonValue));
    }

    /**
     * Copy an image from one host to another
     * Copy an image from one host to another
     */
    async imageScpLibpod(requestParameters: ImageScpLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScpReport> {
        const response = await this.imageScpLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search registries for images
     * Search images
     */
    async imageSearchLibpodRaw(requestParameters: ImageSearchLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageSearch200Response>> {
        const queryParameters: any = {};

        if (requestParameters['term'] != null) {
            queryParameters['term'] = requestParameters['term'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        if (requestParameters['tlsVerify'] != null) {
            queryParameters['tlsVerify'] = requestParameters['tlsVerify'];
        }

        if (requestParameters['listTags'] != null) {
            queryParameters['listTags'] = requestParameters['listTags'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageSearch200ResponseFromJSON(jsonValue));
    }

    /**
     * Search registries for images
     * Search images
     */
    async imageSearchLibpod(requestParameters: ImageSearchLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageSearch200Response> {
        const response = await this.imageSearchLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Tag an image so that it becomes part of a repository.
     * Tag an image
     */
    async imageTagLibpodRaw(requestParameters: ImageTagLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageTagLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['repo'] != null) {
            queryParameters['repo'] = requestParameters['repo'];
        }

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/tag`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Tag an image so that it becomes part of a repository.
     * Tag an image
     */
    async imageTagLibpod(requestParameters: ImageTagLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageTagLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve the image tree for the provided image name or ID
     * Image tree
     */
    async imageTreeLibpodRaw(requestParameters: ImageTreeLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageTreeReport>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageTreeLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['whatrequires'] != null) {
            queryParameters['whatrequires'] = requestParameters['whatrequires'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/tree`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageTreeReportFromJSON(jsonValue));
    }

    /**
     * Retrieve the image tree for the provided image name or ID
     * Image tree
     */
    async imageTreeLibpod(requestParameters: ImageTreeLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageTreeReport> {
        const response = await this.imageTreeLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Untag an image. If not repo and tag are specified, all tags are removed from the image.
     * Untag an image
     */
    async imageUntagLibpodRaw(requestParameters: ImageUntagLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageUntagLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['repo'] != null) {
            queryParameters['repo'] = requestParameters['repo'];
        }

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/images/{name}/untag`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Untag an image. If not repo and tag are specified, all tags are removed from the image.
     * Untag an image
     */
    async imageUntagLibpod(requestParameters: ImageUntagLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageUntagLibpodRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ImageChangesLibpodDiffTypeEnum = {
    All: 'all',
    Container: 'container',
    Image: 'image'
} as const;
export type ImageChangesLibpodDiffTypeEnum = typeof ImageChangesLibpodDiffTypeEnum[keyof typeof ImageChangesLibpodDiffTypeEnum];
/**
 * @export
 */
export const ImageImportLibpodContentTypeEnum = {
    ApplicationXTar: 'application/x-tar'
} as const;
export type ImageImportLibpodContentTypeEnum = typeof ImageImportLibpodContentTypeEnum[keyof typeof ImageImportLibpodContentTypeEnum];
