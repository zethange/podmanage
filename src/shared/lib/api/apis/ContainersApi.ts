/* tslint:disable */
/* eslint-disable */
/**
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  \'podman info\'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  \'podman pull quay.io/containers/podman\'  curl -XPOST --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman\'  \'podman list images\'  curl --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/libpod/images/json\' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ContainerCreateResponse,
  ContainerStats,
  ContainerTopOKBody,
  ContainersPruneReportLibpod,
  ErrorModel,
  HealthCheckResults,
  InspectContainerData,
  LibpodContainersRmReport,
  ListContainer,
  PlayKubeReport,
  SpecGenerator,
  UpdateEntities,
} from '../models/index';
import {
    ContainerCreateResponseFromJSON,
    ContainerCreateResponseToJSON,
    ContainerStatsFromJSON,
    ContainerStatsToJSON,
    ContainerTopOKBodyFromJSON,
    ContainerTopOKBodyToJSON,
    ContainersPruneReportLibpodFromJSON,
    ContainersPruneReportLibpodToJSON,
    ErrorModelFromJSON,
    ErrorModelToJSON,
    HealthCheckResultsFromJSON,
    HealthCheckResultsToJSON,
    InspectContainerDataFromJSON,
    InspectContainerDataToJSON,
    LibpodContainersRmReportFromJSON,
    LibpodContainersRmReportToJSON,
    ListContainerFromJSON,
    ListContainerToJSON,
    PlayKubeReportFromJSON,
    PlayKubeReportToJSON,
    SpecGeneratorFromJSON,
    SpecGeneratorToJSON,
    UpdateEntitiesFromJSON,
    UpdateEntitiesToJSON,
} from '../models/index';

export interface ContainerAttachLibpodRequest {
    name: string;
    detachKeys?: string;
    logs?: boolean;
    stream?: boolean;
    stdout?: boolean;
    stderr?: boolean;
    stdin?: boolean;
}

export interface ContainerChangesLibpodRequest {
    name: string;
    parent?: string;
    diffType?: ContainerChangesLibpodDiffTypeEnum;
}

export interface ContainerCheckpointLibpodRequest {
    name: string;
    keep?: boolean;
    leaveRunning?: boolean;
    tcpEstablished?: boolean;
    _export?: boolean;
    ignoreRootFS?: boolean;
    ignoreVolumes?: boolean;
    preCheckpoint?: boolean;
    withPrevious?: boolean;
    fileLocks?: boolean;
    printStats?: boolean;
}

export interface ContainerCreateLibpodRequest {
    create: SpecGenerator;
}

export interface ContainerDeleteLibpodRequest {
    name: string;
    depend?: boolean;
    force?: boolean;
    ignore?: boolean;
    timeout?: number;
    v?: boolean;
}

export interface ContainerExistsLibpodRequest {
    name: string;
}

export interface ContainerExportLibpodRequest {
    name: string;
}

export interface ContainerHealthcheckLibpodRequest {
    name: string;
}

export interface ContainerInitLibpodRequest {
    name: string;
}

export interface ContainerInspectLibpodRequest {
    name: string;
    size?: boolean;
}

export interface ContainerKillLibpodRequest {
    name: string;
    signal?: string;
}

export interface ContainerListLibpodRequest {
    all?: boolean;
    limit?: number;
    namespace?: boolean;
    pod?: boolean;
    size?: boolean;
    sync?: boolean;
    filters?: string;
}

export interface ContainerLogsLibpodRequest {
    name: string;
    follow?: boolean;
    stdout?: boolean;
    stderr?: boolean;
    since?: string;
    until?: string;
    timestamps?: boolean;
    tail?: string;
}

export interface ContainerMountLibpodRequest {
    name: string;
}

export interface ContainerPauseLibpodRequest {
    name: string;
}

export interface ContainerPruneLibpodRequest {
    filters?: string;
}

export interface ContainerRenameLibpodRequest {
    name: string;
    name2: string;
}

export interface ContainerResizeLibpodRequest {
    name: string;
    h?: number;
    w?: number;
}

export interface ContainerRestartLibpodRequest {
    name: string;
    t?: number;
}

export interface ContainerRestoreLibpodRequest {
    name: string;
    name2?: string;
    keep?: boolean;
    tcpEstablished?: boolean;
    _import?: boolean;
    ignoreRootFS?: boolean;
    ignoreVolumes?: boolean;
    ignoreStaticIP?: boolean;
    ignoreStaticMAC?: boolean;
    fileLocks?: boolean;
    printStats?: boolean;
    pod?: string;
}

export interface ContainerStartLibpodRequest {
    name: string;
    detachKeys?: string;
}

export interface ContainerStatsLibpodRequest {
    name: string;
    stream?: boolean;
}

export interface ContainerStopLibpodRequest {
    name: string;
    timeout?: number;
    ignore?: boolean;
}

export interface ContainerTopLibpodRequest {
    name: string;
    stream?: boolean;
    delay?: number;
    psArgs?: Array<string>;
}

export interface ContainerUnmountLibpodRequest {
    name: string;
}

export interface ContainerUnpauseLibpodRequest {
    name: string;
}

export interface ContainerUpdateLibpodRequest {
    name: string;
    restartPolicy?: string;
    restartRetries?: number;
    config?: UpdateEntities;
}

export interface ContainerWaitLibpodRequest {
    name: string;
    condition?: Array<ContainerWaitLibpodConditionEnum>;
    interval?: string;
}

export interface ContainersStatsAllLibpodRequest {
    containers?: Array<string>;
    stream?: boolean;
    interval?: number;
}

export interface GenerateKubeLibpodRequest {
    names: Array<string>;
    service?: boolean;
    type?: string;
    replicas?: number;
    noTrunc?: boolean;
    podmanOnly?: boolean;
}

export interface GenerateSystemdLibpodRequest {
    name: string;
    useName?: boolean;
    _new?: boolean;
    noHeader?: boolean;
    startTimeout?: number;
    stopTimeout?: number;
    restartPolicy?: GenerateSystemdLibpodRestartPolicyEnum;
    containerPrefix?: string;
    podPrefix?: string;
    separator?: string;
    restartSec?: number;
    wants?: Array<string>;
    after?: Array<string>;
    requires?: Array<string>;
    additionalEnvVariables?: Array<string>;
}

export interface ImageCommitLibpodRequest {
    container: string;
    author?: string;
    changes?: Array<string>;
    comment?: string;
    format?: string;
    pause?: boolean;
    squash?: boolean;
    repo?: string;
    stream?: boolean;
    tag?: string;
}

export interface KubeApplyLibpodRequest {
    caCertFile?: string;
    kubeConfig?: string;
    namespace?: string;
    service?: boolean;
    file?: string;
    request?: string;
}

export interface PlayKubeDownLibpodRequest {
    force?: boolean;
}

export interface PlayKubeLibpodRequest {
    annotations?: string;
    logDriver?: string;
    logOptions?: Array<string>;
    network?: Array<string>;
    noHosts?: boolean;
    noTrunc?: boolean;
    publishPorts?: Array<string>;
    publishAllPorts?: boolean;
    replace?: boolean;
    serviceContainer?: boolean;
    start?: boolean;
    staticIPs?: Array<string>;
    staticMACs?: Array<string>;
    tlsVerify?: boolean;
    userns?: string;
    wait?: boolean;
    request?: string;
}

export interface PutContainerArchiveLibpodRequest {
    name: string;
    path: string;
    pause?: boolean;
    request?: string;
}

/**
 * 
 */
export class ContainersApi extends runtime.BaseAPI {

    /**
     * Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  ### Hijacking  This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.  This is the response from the service for an attach request:  ``` HTTP/1.1 200 OK Content-Type: application/vnd.docker.raw-stream  [STREAM] ```  After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.  To inform potential proxies about connection hijacking, the client can also optionally send connection upgrade headers.  For example, the client sends this request to upgrade the connection:  ``` POST /v4.6.0/libpod/containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1 Upgrade: tcp Connection: Upgrade ```  The service will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:  ``` HTTP/1.1 101 UPGRADED Content-Type: application/vnd.docker.raw-stream Connection: Upgrade Upgrade: tcp  [STREAM] ```  ### Stream format  When the TTY setting is disabled for the container, the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream (starting with v4.7.0, previously application/vnd.docker.raw-stream was always used) and the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.  The header contains the information about the output stream type and the size of the payload. It is encoded on the first eight bytes like this:  ```go header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4} ```  `STREAM_TYPE` can be:  - 0: `stdin` (is written on `stdout`) - 1: `stdout` - 2: `stderr`  `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.  Following the header is the payload, which contains the specified number of bytes as written in the size.  The simplest way to implement this protocol is the following:  1. Read 8 bytes. 2. Choose `stdout` or `stderr` depending on the first byte. 3. Extract the frame size from the last four bytes. 4. Read the extracted size and output it on the correct output. 5. Goto 1.  ### Stream format when using a TTY  When the TTY setting is enabled for the container, the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client\'s `stdin`. 
     * Attach to a container
     */
    async containerAttachLibpodRaw(requestParameters: ContainerAttachLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerAttachLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['detachKeys'] != null) {
            queryParameters['detachKeys'] = requestParameters['detachKeys'];
        }

        if (requestParameters['logs'] != null) {
            queryParameters['logs'] = requestParameters['logs'];
        }

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['stdin'] != null) {
            queryParameters['stdin'] = requestParameters['stdin'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  ### Hijacking  This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.  This is the response from the service for an attach request:  ``` HTTP/1.1 200 OK Content-Type: application/vnd.docker.raw-stream  [STREAM] ```  After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.  To inform potential proxies about connection hijacking, the client can also optionally send connection upgrade headers.  For example, the client sends this request to upgrade the connection:  ``` POST /v4.6.0/libpod/containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1 Upgrade: tcp Connection: Upgrade ```  The service will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:  ``` HTTP/1.1 101 UPGRADED Content-Type: application/vnd.docker.raw-stream Connection: Upgrade Upgrade: tcp  [STREAM] ```  ### Stream format  When the TTY setting is disabled for the container, the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream (starting with v4.7.0, previously application/vnd.docker.raw-stream was always used) and the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.  The header contains the information about the output stream type and the size of the payload. It is encoded on the first eight bytes like this:  ```go header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4} ```  `STREAM_TYPE` can be:  - 0: `stdin` (is written on `stdout`) - 1: `stdout` - 2: `stderr`  `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.  Following the header is the payload, which contains the specified number of bytes as written in the size.  The simplest way to implement this protocol is the following:  1. Read 8 bytes. 2. Choose `stdout` or `stderr` depending on the first byte. 3. Extract the frame size from the last four bytes. 4. Read the extracted size and output it on the correct output. 5. Goto 1.  ### Stream format when using a TTY  When the TTY setting is enabled for the container, the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client\'s `stdin`. 
     * Attach to a container
     */
    async containerAttachLibpod(requestParameters: ContainerAttachLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerAttachLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Returns which files in a container\'s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
     * Report on changes to container\'s filesystem; adds, deletes or modifications.
     */
    async containerChangesLibpodRaw(requestParameters: ContainerChangesLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerChangesLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['parent'] != null) {
            queryParameters['parent'] = requestParameters['parent'];
        }

        if (requestParameters['diffType'] != null) {
            queryParameters['diffType'] = requestParameters['diffType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/changes`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns which files in a container\'s filesystem have been added, deleted, or modified. The Kind of modification can be one of:  0: Modified 1: Added 2: Deleted 
     * Report on changes to container\'s filesystem; adds, deletes or modifications.
     */
    async containerChangesLibpod(requestParameters: ContainerChangesLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerChangesLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Checkpoint a container
     */
    async containerCheckpointLibpodRaw(requestParameters: ContainerCheckpointLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerCheckpointLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['keep'] != null) {
            queryParameters['keep'] = requestParameters['keep'];
        }

        if (requestParameters['leaveRunning'] != null) {
            queryParameters['leaveRunning'] = requestParameters['leaveRunning'];
        }

        if (requestParameters['tcpEstablished'] != null) {
            queryParameters['tcpEstablished'] = requestParameters['tcpEstablished'];
        }

        if (requestParameters['_export'] != null) {
            queryParameters['export'] = requestParameters['_export'];
        }

        if (requestParameters['ignoreRootFS'] != null) {
            queryParameters['ignoreRootFS'] = requestParameters['ignoreRootFS'];
        }

        if (requestParameters['ignoreVolumes'] != null) {
            queryParameters['ignoreVolumes'] = requestParameters['ignoreVolumes'];
        }

        if (requestParameters['preCheckpoint'] != null) {
            queryParameters['preCheckpoint'] = requestParameters['preCheckpoint'];
        }

        if (requestParameters['withPrevious'] != null) {
            queryParameters['withPrevious'] = requestParameters['withPrevious'];
        }

        if (requestParameters['fileLocks'] != null) {
            queryParameters['fileLocks'] = requestParameters['fileLocks'];
        }

        if (requestParameters['printStats'] != null) {
            queryParameters['printStats'] = requestParameters['printStats'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/checkpoint`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Checkpoint a container
     */
    async containerCheckpointLibpod(requestParameters: ContainerCheckpointLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerCheckpointLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Create a container
     */
    async containerCreateLibpodRaw(requestParameters: ContainerCreateLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContainerCreateResponse>> {
        if (requestParameters['create'] == null) {
            throw new runtime.RequiredError(
                'create',
                'Required parameter "create" was null or undefined when calling containerCreateLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/libpod/containers/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SpecGeneratorToJSON(requestParameters['create']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContainerCreateResponseFromJSON(jsonValue));
    }

    /**
     * Create a container
     */
    async containerCreateLibpod(requestParameters: ContainerCreateLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContainerCreateResponse> {
        const response = await this.containerCreateLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete container
     * Delete container
     */
    async containerDeleteLibpodRaw(requestParameters: ContainerDeleteLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LibpodContainersRmReport>>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerDeleteLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['depend'] != null) {
            queryParameters['depend'] = requestParameters['depend'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        if (requestParameters['ignore'] != null) {
            queryParameters['ignore'] = requestParameters['ignore'];
        }

        if (requestParameters['timeout'] != null) {
            queryParameters['timeout'] = requestParameters['timeout'];
        }

        if (requestParameters['v'] != null) {
            queryParameters['v'] = requestParameters['v'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LibpodContainersRmReportFromJSON));
    }

    /**
     * Delete container
     * Delete container
     */
    async containerDeleteLibpod(requestParameters: ContainerDeleteLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LibpodContainersRmReport> | null | undefined > {
        const response = await this.containerDeleteLibpodRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Quick way to determine if a container exists by name or ID
     * Check if container exists
     */
    async containerExistsLibpodRaw(requestParameters: ContainerExistsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerExistsLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/exists`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Quick way to determine if a container exists by name or ID
     * Check if container exists
     */
    async containerExistsLibpod(requestParameters: ContainerExistsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerExistsLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Export the contents of a container as a tarball.
     * Export a container
     */
    async containerExportLibpodRaw(requestParameters: ContainerExportLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerExportLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/export`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Export the contents of a container as a tarball.
     * Export a container
     */
    async containerExportLibpod(requestParameters: ContainerExportLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerExportLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Execute the defined healthcheck and return information about the results
     * Run a container\'s healthcheck
     */
    async containerHealthcheckLibpodRaw(requestParameters: ContainerHealthcheckLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthCheckResults>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerHealthcheckLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/healthcheck`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthCheckResultsFromJSON(jsonValue));
    }

    /**
     * Execute the defined healthcheck and return information about the results
     * Run a container\'s healthcheck
     */
    async containerHealthcheckLibpod(requestParameters: ContainerHealthcheckLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthCheckResults> {
        const response = await this.containerHealthcheckLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs all tasks necessary for initializing the container but does not start the container.
     * Initialize a container
     */
    async containerInitLibpodRaw(requestParameters: ContainerInitLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerInitLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/init`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Performs all tasks necessary for initializing the container but does not start the container.
     * Initialize a container
     */
    async containerInitLibpod(requestParameters: ContainerInitLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerInitLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Return low-level information about a container.
     * Inspect container
     */
    async containerInspectLibpodRaw(requestParameters: ContainerInspectLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InspectContainerData>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerInspectLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InspectContainerDataFromJSON(jsonValue));
    }

    /**
     * Return low-level information about a container.
     * Inspect container
     */
    async containerInspectLibpod(requestParameters: ContainerInspectLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InspectContainerData> {
        const response = await this.containerInspectLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * send a signal to a container, defaults to killing the container
     * Kill container
     */
    async containerKillLibpodRaw(requestParameters: ContainerKillLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerKillLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['signal'] != null) {
            queryParameters['signal'] = requestParameters['signal'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/kill`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * send a signal to a container, defaults to killing the container
     * Kill container
     */
    async containerKillLibpod(requestParameters: ContainerKillLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerKillLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of containers
     * List containers
     */
    async containerListLibpodRaw(requestParameters: ContainerListLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ListContainer>>> {
        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['namespace'] != null) {
            queryParameters['namespace'] = requestParameters['namespace'];
        }

        if (requestParameters['pod'] != null) {
            queryParameters['pod'] = requestParameters['pod'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['sync'] != null) {
            queryParameters['sync'] = requestParameters['sync'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ListContainerFromJSON));
    }

    /**
     * Returns a list of containers
     * List containers
     */
    async containerListLibpod(requestParameters: ContainerListLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ListContainer>> {
        const response = await this.containerListLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get stdout and stderr logs from a container.  The stream format is the same as described in the attach endpoint. 
     * Get container logs
     */
    async containerLogsLibpodRaw(requestParameters: ContainerLogsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerLogsLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['follow'] != null) {
            queryParameters['follow'] = requestParameters['follow'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['since'] != null) {
            queryParameters['since'] = requestParameters['since'];
        }

        if (requestParameters['until'] != null) {
            queryParameters['until'] = requestParameters['until'];
        }

        if (requestParameters['timestamps'] != null) {
            queryParameters['timestamps'] = requestParameters['timestamps'];
        }

        if (requestParameters['tail'] != null) {
            queryParameters['tail'] = requestParameters['tail'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/logs`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get stdout and stderr logs from a container.  The stream format is the same as described in the attach endpoint. 
     * Get container logs
     */
    async containerLogsLibpod(requestParameters: ContainerLogsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerLogsLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Mount a container to the filesystem
     * Mount a container
     */
    async containerMountLibpodRaw(requestParameters: ContainerMountLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerMountLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/mount`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Mount a container to the filesystem
     * Mount a container
     */
    async containerMountLibpod(requestParameters: ContainerMountLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.containerMountLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use the cgroups freezer to suspend all processes in a container.
     * Pause a container
     */
    async containerPauseLibpodRaw(requestParameters: ContainerPauseLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerPauseLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/pause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use the cgroups freezer to suspend all processes in a container.
     * Pause a container
     */
    async containerPauseLibpod(requestParameters: ContainerPauseLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerPauseLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Remove containers not in use
     * Delete stopped containers
     */
    async containerPruneLibpodRaw(requestParameters: ContainerPruneLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContainersPruneReportLibpod>>> {
        const queryParameters: any = {};

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/prune`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContainersPruneReportLibpodFromJSON));
    }

    /**
     * Remove containers not in use
     * Delete stopped containers
     */
    async containerPruneLibpod(requestParameters: ContainerPruneLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContainersPruneReportLibpod>> {
        const response = await this.containerPruneLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Change the name of an existing container.
     * Rename an existing container
     */
    async containerRenameLibpodRaw(requestParameters: ContainerRenameLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerRenameLibpod().'
            );
        }

        if (requestParameters['name2'] == null) {
            throw new runtime.RequiredError(
                'name2',
                'Required parameter "name2" was null or undefined when calling containerRenameLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name2'] != null) {
            queryParameters['name'] = requestParameters['name2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/rename`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the name of an existing container.
     * Rename an existing container
     */
    async containerRenameLibpod(requestParameters: ContainerRenameLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerRenameLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Resize the terminal attached to a container (for use with Attach).
     * Resize a container\'s TTY
     */
    async containerResizeLibpodRaw(requestParameters: ContainerResizeLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerResizeLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['h'] != null) {
            queryParameters['h'] = requestParameters['h'];
        }

        if (requestParameters['w'] != null) {
            queryParameters['w'] = requestParameters['w'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/resize`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Resize the terminal attached to a container (for use with Attach).
     * Resize a container\'s TTY
     */
    async containerResizeLibpod(requestParameters: ContainerResizeLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.containerResizeLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restart a container
     */
    async containerRestartLibpodRaw(requestParameters: ContainerRestartLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerRestartLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['t'] != null) {
            queryParameters['t'] = requestParameters['t'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/restart`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Restart a container
     */
    async containerRestartLibpod(requestParameters: ContainerRestartLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerRestartLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Restore a container from a checkpoint.
     * Restore a container
     */
    async containerRestoreLibpodRaw(requestParameters: ContainerRestoreLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerRestoreLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name2'] != null) {
            queryParameters['name'] = requestParameters['name2'];
        }

        if (requestParameters['keep'] != null) {
            queryParameters['keep'] = requestParameters['keep'];
        }

        if (requestParameters['tcpEstablished'] != null) {
            queryParameters['tcpEstablished'] = requestParameters['tcpEstablished'];
        }

        if (requestParameters['_import'] != null) {
            queryParameters['import'] = requestParameters['_import'];
        }

        if (requestParameters['ignoreRootFS'] != null) {
            queryParameters['ignoreRootFS'] = requestParameters['ignoreRootFS'];
        }

        if (requestParameters['ignoreVolumes'] != null) {
            queryParameters['ignoreVolumes'] = requestParameters['ignoreVolumes'];
        }

        if (requestParameters['ignoreStaticIP'] != null) {
            queryParameters['ignoreStaticIP'] = requestParameters['ignoreStaticIP'];
        }

        if (requestParameters['ignoreStaticMAC'] != null) {
            queryParameters['ignoreStaticMAC'] = requestParameters['ignoreStaticMAC'];
        }

        if (requestParameters['fileLocks'] != null) {
            queryParameters['fileLocks'] = requestParameters['fileLocks'];
        }

        if (requestParameters['printStats'] != null) {
            queryParameters['printStats'] = requestParameters['printStats'];
        }

        if (requestParameters['pod'] != null) {
            queryParameters['pod'] = requestParameters['pod'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/restore`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Restore a container from a checkpoint.
     * Restore a container
     */
    async containerRestoreLibpod(requestParameters: ContainerRestoreLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerRestoreLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Lists all mounted containers mount points
     * Show mounted containers
     */
    async containerShowMountedLibpodRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: string; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/showmounted`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Lists all mounted containers mount points
     * Show mounted containers
     */
    async containerShowMountedLibpod(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: string; }> {
        const response = await this.containerShowMountedLibpodRaw(initOverrides);
        return await response.value();
    }

    /**
     * Start a container
     */
    async containerStartLibpodRaw(requestParameters: ContainerStartLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerStartLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['detachKeys'] != null) {
            queryParameters['detachKeys'] = requestParameters['detachKeys'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/start`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Start a container
     */
    async containerStartLibpod(requestParameters: ContainerStartLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerStartLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * DEPRECATED. This endpoint will be removed with the next major release. Please use /libpod/containers/stats instead.
     * Get stats for a container
     */
    async containerStatsLibpodRaw(requestParameters: ContainerStatsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerStatsLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/stats`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * DEPRECATED. This endpoint will be removed with the next major release. Please use /libpod/containers/stats instead.
     * Get stats for a container
     */
    async containerStatsLibpod(requestParameters: ContainerStatsLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerStatsLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Stop a container
     */
    async containerStopLibpodRaw(requestParameters: ContainerStopLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerStopLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['timeout'] != null) {
            queryParameters['timeout'] = requestParameters['timeout'];
        }

        if (requestParameters['ignore'] != null) {
            queryParameters['Ignore'] = requestParameters['ignore'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/stop`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop a container
     */
    async containerStopLibpod(requestParameters: ContainerStopLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerStopLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * List processes running inside a container
     * List processes
     */
    async containerTopLibpodRaw(requestParameters: ContainerTopLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContainerTopOKBody>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerTopLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        if (requestParameters['delay'] != null) {
            queryParameters['delay'] = requestParameters['delay'];
        }

        if (requestParameters['psArgs'] != null) {
            queryParameters['ps_args'] = requestParameters['psArgs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/top`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContainerTopOKBodyFromJSON(jsonValue));
    }

    /**
     * List processes running inside a container
     * List processes
     */
    async containerTopLibpod(requestParameters: ContainerTopLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContainerTopOKBody> {
        const response = await this.containerTopLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unmount a container from the filesystem
     * Unmount a container
     */
    async containerUnmountLibpodRaw(requestParameters: ContainerUnmountLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerUnmountLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/unmount`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unmount a container from the filesystem
     * Unmount a container
     */
    async containerUnmountLibpod(requestParameters: ContainerUnmountLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerUnmountLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Unpause Container
     */
    async containerUnpauseLibpodRaw(requestParameters: ContainerUnpauseLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerUnpauseLibpod().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/unpause`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unpause Container
     */
    async containerUnpauseLibpod(requestParameters: ContainerUnpauseLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerUnpauseLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Update an existing containers cgroup configuration.
     * Update an existing containers cgroup configuration
     */
    async containerUpdateLibpodRaw(requestParameters: ContainerUpdateLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerUpdateLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['restartPolicy'] != null) {
            queryParameters['restartPolicy'] = requestParameters['restartPolicy'];
        }

        if (requestParameters['restartRetries'] != null) {
            queryParameters['restartRetries'] = requestParameters['restartRetries'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/libpod/containers/{name}/update`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEntitiesToJSON(requestParameters['config']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update an existing containers cgroup configuration.
     * Update an existing containers cgroup configuration
     */
    async containerUpdateLibpod(requestParameters: ContainerUpdateLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.containerUpdateLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Wait on a container to meet a given condition
     * Wait on a container
     */
    async containerWaitLibpodRaw(requestParameters: ContainerWaitLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling containerWaitLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['condition'] != null) {
            queryParameters['condition'] = requestParameters['condition']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['interval'] != null) {
            queryParameters['interval'] = requestParameters['interval'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/{name}/wait`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<number>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Wait on a container to meet a given condition
     * Wait on a container
     */
    async containerWaitLibpod(requestParameters: ContainerWaitLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.containerWaitLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a live stream of resource usage statistics of one or more container. If no container is specified, the statistics of all containers are returned.
     * Get stats for one or more containers
     */
    async containersStatsAllLibpodRaw(requestParameters: ContainersStatsAllLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContainerStats>> {
        const queryParameters: any = {};

        if (requestParameters['containers'] != null) {
            queryParameters['containers'] = requestParameters['containers']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        if (requestParameters['interval'] != null) {
            queryParameters['interval'] = requestParameters['interval'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/containers/stats`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContainerStatsFromJSON(jsonValue));
    }

    /**
     * Return a live stream of resource usage statistics of one or more container. If no container is specified, the statistics of all containers are returned.
     * Get stats for one or more containers
     */
    async containersStatsAllLibpod(requestParameters: ContainersStatsAllLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContainerStats> {
        const response = await this.containersStatsAllLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate Kubernetes YAML based on a pod or container.
     * Generate a Kubernetes YAML file.
     */
    async generateKubeLibpodRaw(requestParameters: GenerateKubeLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['names'] == null) {
            throw new runtime.RequiredError(
                'names',
                'Required parameter "names" was null or undefined when calling generateKubeLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['names'] != null) {
            queryParameters['names'] = requestParameters['names']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['service'] != null) {
            queryParameters['service'] = requestParameters['service'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['replicas'] != null) {
            queryParameters['replicas'] = requestParameters['replicas'];
        }

        if (requestParameters['noTrunc'] != null) {
            queryParameters['noTrunc'] = requestParameters['noTrunc'];
        }

        if (requestParameters['podmanOnly'] != null) {
            queryParameters['podmanOnly'] = requestParameters['podmanOnly'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/generate/kube`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Generate Kubernetes YAML based on a pod or container.
     * Generate a Kubernetes YAML file.
     */
    async generateKubeLibpod(requestParameters: GenerateKubeLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.generateKubeLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate Systemd Units based on a pod or container.
     * Generate Systemd Units
     */
    async generateSystemdLibpodRaw(requestParameters: GenerateSystemdLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: string; }>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling generateSystemdLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useName'] != null) {
            queryParameters['useName'] = requestParameters['useName'];
        }

        if (requestParameters['_new'] != null) {
            queryParameters['new'] = requestParameters['_new'];
        }

        if (requestParameters['noHeader'] != null) {
            queryParameters['noHeader'] = requestParameters['noHeader'];
        }

        if (requestParameters['startTimeout'] != null) {
            queryParameters['startTimeout'] = requestParameters['startTimeout'];
        }

        if (requestParameters['stopTimeout'] != null) {
            queryParameters['stopTimeout'] = requestParameters['stopTimeout'];
        }

        if (requestParameters['restartPolicy'] != null) {
            queryParameters['restartPolicy'] = requestParameters['restartPolicy'];
        }

        if (requestParameters['containerPrefix'] != null) {
            queryParameters['containerPrefix'] = requestParameters['containerPrefix'];
        }

        if (requestParameters['podPrefix'] != null) {
            queryParameters['podPrefix'] = requestParameters['podPrefix'];
        }

        if (requestParameters['separator'] != null) {
            queryParameters['separator'] = requestParameters['separator'];
        }

        if (requestParameters['restartSec'] != null) {
            queryParameters['restartSec'] = requestParameters['restartSec'];
        }

        if (requestParameters['wants'] != null) {
            queryParameters['wants'] = requestParameters['wants']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['requires'] != null) {
            queryParameters['requires'] = requestParameters['requires']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['additionalEnvVariables'] != null) {
            queryParameters['additionalEnvVariables'] = requestParameters['additionalEnvVariables']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/generate/{name}/systemd`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Generate Systemd Units based on a pod or container.
     * Generate Systemd Units
     */
    async generateSystemdLibpod(requestParameters: GenerateSystemdLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: string; }> {
        const response = await this.generateSystemdLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new image from a container
     * Commit
     */
    async imageCommitLibpodRaw(requestParameters: ImageCommitLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['container'] == null) {
            throw new runtime.RequiredError(
                'container',
                'Required parameter "container" was null or undefined when calling imageCommitLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['container'] != null) {
            queryParameters['container'] = requestParameters['container'];
        }

        if (requestParameters['author'] != null) {
            queryParameters['author'] = requestParameters['author'];
        }

        if (requestParameters['changes'] != null) {
            queryParameters['changes'] = requestParameters['changes']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['comment'] != null) {
            queryParameters['comment'] = requestParameters['comment'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['pause'] != null) {
            queryParameters['pause'] = requestParameters['pause'];
        }

        if (requestParameters['squash'] != null) {
            queryParameters['squash'] = requestParameters['squash'];
        }

        if (requestParameters['repo'] != null) {
            queryParameters['repo'] = requestParameters['repo'];
        }

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/commit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new image from a container
     * Commit
     */
    async imageCommitLibpod(requestParameters: ImageCommitLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageCommitLibpodRaw(requestParameters, initOverrides);
    }

    /**
     * Deploy a podman container, pod, volume, or Kubernetes yaml to a Kubernetes cluster.
     * Apply a podman workload or Kubernetes YAML file.
     */
    async kubeApplyLibpodRaw(requestParameters: KubeApplyLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        if (requestParameters['caCertFile'] != null) {
            queryParameters['caCertFile'] = requestParameters['caCertFile'];
        }

        if (requestParameters['kubeConfig'] != null) {
            queryParameters['kubeConfig'] = requestParameters['kubeConfig'];
        }

        if (requestParameters['namespace'] != null) {
            queryParameters['namespace'] = requestParameters['namespace'];
        }

        if (requestParameters['service'] != null) {
            queryParameters['service'] = requestParameters['service'];
        }

        if (requestParameters['file'] != null) {
            queryParameters['file'] = requestParameters['file'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/libpod/kube/apply`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'] as any,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Deploy a podman container, pod, volume, or Kubernetes yaml to a Kubernetes cluster.
     * Apply a podman workload or Kubernetes YAML file.
     */
    async kubeApplyLibpod(requestParameters: KubeApplyLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.kubeApplyLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Tears down pods, secrets, and volumes defined in a YAML file
     * Remove resources created from kube play
     */
    async playKubeDownLibpodRaw(requestParameters: PlayKubeDownLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlayKubeReport>> {
        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/libpod/play/kube`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlayKubeReportFromJSON(jsonValue));
    }

    /**
     * Tears down pods, secrets, and volumes defined in a YAML file
     * Remove resources created from kube play
     */
    async playKubeDownLibpod(requestParameters: PlayKubeDownLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlayKubeReport> {
        const response = await this.playKubeDownLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create and run pods based on a Kubernetes YAML file (pod or service kind).
     * Play a Kubernetes YAML file.
     */
    async playKubeLibpodRaw(requestParameters: PlayKubeLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlayKubeReport>> {
        const queryParameters: any = {};

        if (requestParameters['annotations'] != null) {
            queryParameters['annotations'] = requestParameters['annotations'];
        }

        if (requestParameters['logDriver'] != null) {
            queryParameters['logDriver'] = requestParameters['logDriver'];
        }

        if (requestParameters['logOptions'] != null) {
            queryParameters['logOptions'] = requestParameters['logOptions']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['network'] != null) {
            queryParameters['network'] = requestParameters['network']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['noHosts'] != null) {
            queryParameters['noHosts'] = requestParameters['noHosts'];
        }

        if (requestParameters['noTrunc'] != null) {
            queryParameters['noTrunc'] = requestParameters['noTrunc'];
        }

        if (requestParameters['publishPorts'] != null) {
            queryParameters['publishPorts'] = requestParameters['publishPorts']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['publishAllPorts'] != null) {
            queryParameters['publishAllPorts'] = requestParameters['publishAllPorts'];
        }

        if (requestParameters['replace'] != null) {
            queryParameters['replace'] = requestParameters['replace'];
        }

        if (requestParameters['serviceContainer'] != null) {
            queryParameters['serviceContainer'] = requestParameters['serviceContainer'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['staticIPs'] != null) {
            queryParameters['staticIPs'] = requestParameters['staticIPs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['staticMACs'] != null) {
            queryParameters['staticMACs'] = requestParameters['staticMACs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['tlsVerify'] != null) {
            queryParameters['tlsVerify'] = requestParameters['tlsVerify'];
        }

        if (requestParameters['userns'] != null) {
            queryParameters['userns'] = requestParameters['userns'];
        }

        if (requestParameters['wait'] != null) {
            queryParameters['wait'] = requestParameters['wait'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/libpod/play/kube`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlayKubeReportFromJSON(jsonValue));
    }

    /**
     * Create and run pods based on a Kubernetes YAML file (pod or service kind).
     * Play a Kubernetes YAML file.
     */
    async playKubeLibpod(requestParameters: PlayKubeLibpodRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlayKubeReport> {
        const response = await this.playKubeLibpodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Copy a tar archive of files into a container
     * Copy files into a container
     */
    async putContainerArchiveLibpodRaw(requestParameters: PutContainerArchiveLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling putContainerArchiveLibpod().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling putContainerArchiveLibpod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['pause'] != null) {
            queryParameters['pause'] = requestParameters['pause'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/libpod/containers/{name}/archive`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Copy a tar archive of files into a container
     * Copy files into a container
     */
    async putContainerArchiveLibpod(requestParameters: PutContainerArchiveLibpodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putContainerArchiveLibpodRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ContainerChangesLibpodDiffTypeEnum = {
    All: 'all',
    Container: 'container',
    Image: 'image'
} as const;
export type ContainerChangesLibpodDiffTypeEnum = typeof ContainerChangesLibpodDiffTypeEnum[keyof typeof ContainerChangesLibpodDiffTypeEnum];
/**
 * @export
 */
export const ContainerWaitLibpodConditionEnum = {
    Configured: 'configured',
    Created: 'created',
    Exited: 'exited',
    Healthy: 'healthy',
    Initialized: 'initialized',
    Paused: 'paused',
    Removing: 'removing',
    Running: 'running',
    Stopped: 'stopped',
    Stopping: 'stopping',
    Unhealthy: 'unhealthy'
} as const;
export type ContainerWaitLibpodConditionEnum = typeof ContainerWaitLibpodConditionEnum[keyof typeof ContainerWaitLibpodConditionEnum];
/**
 * @export
 */
export const GenerateSystemdLibpodRestartPolicyEnum = {
    No: 'no',
    OnSuccess: 'on-success',
    OnFailure: 'on-failure',
    OnAbnormal: 'on-abnormal',
    OnWatchdog: 'on-watchdog',
    OnAbort: 'on-abort',
    Always: 'always'
} as const;
export type GenerateSystemdLibpodRestartPolicyEnum = typeof GenerateSystemdLibpodRestartPolicyEnum[keyof typeof GenerateSystemdLibpodRestartPolicyEnum];
