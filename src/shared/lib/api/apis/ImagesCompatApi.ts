/* tslint:disable */
/* eslint-disable */
/**
 * supports a RESTful API for the Libpod library
 * This documentation describes the Podman v2.x+ RESTful API. It consists of a Docker-compatible API and a Libpod API providing support for Podmanâ€™s unique features such as pods.  To start the service and keep it running for 5,000 seconds (-t 0 runs forever):  podman system service -t 5000 &  You can then use cURL on the socket using requests documented below.  NOTE: if you install the package podman-docker, it will create a symbolic link for /run/docker.sock to /run/podman/podman.sock  NOTE: Some fields in the API response JSON are encoded as omitempty, which means that if said field has a zero value, they will not be encoded in the API response. This is a feature to help reduce the size of the JSON responses returned via the API.  NOTE: Due to the limitations of [go-swagger](https://github.com/go-swagger/go-swagger), some field values that have a complex type show up as null in the docs as well as in the API responses. This is because the zero value for the field type is null. The field description in the docs will state what type the field is expected to be for such cases.  See podman-system-service(1) for more information.  Quick Examples:  \'podman info\'  curl --unix-socket /run/podman/podman.sock http://d/v5.0.0/libpod/info  \'podman pull quay.io/containers/podman\'  curl -XPOST --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/images/create?fromImage=quay.io%2Fcontainers%2Fpodman\'  \'podman list images\'  curl --unix-socket /run/podman/podman.sock -v \'http://d/v5.0.0/libpod/images/json\' | jq
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: podman@lists.podman.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorModel,
  HistoryResponse,
  ImageBuild200Response,
  ImageDelete200ResponseInner,
  ImageInspect,
  ImageSearch200Response,
  Summary,
} from '../models/index';
import {
    ErrorModelFromJSON,
    ErrorModelToJSON,
    HistoryResponseFromJSON,
    HistoryResponseToJSON,
    ImageBuild200ResponseFromJSON,
    ImageBuild200ResponseToJSON,
    ImageDelete200ResponseInnerFromJSON,
    ImageDelete200ResponseInnerToJSON,
    ImageInspectFromJSON,
    ImageInspectToJSON,
    ImageSearch200ResponseFromJSON,
    ImageSearch200ResponseToJSON,
    SummaryFromJSON,
    SummaryToJSON,
} from '../models/index';

export interface ImageBuildRequest {
    contentType?: ImageBuildContentTypeEnum;
    xRegistryConfig?: string;
    dockerfile?: string;
    t?: string;
    extrahosts?: string;
    remote?: string;
    q?: boolean;
    nocache?: boolean;
    cachefrom?: string;
    pull?: boolean;
    rm?: boolean;
    forcerm?: boolean;
    memory?: number;
    memswap?: number;
    cpushares?: number;
    cpusetcpus?: string;
    cpuperiod?: number;
    cpuquota?: number;
    buildargs?: string;
    shmsize?: number;
    squash?: boolean;
    labels?: string;
    networkmode?: string;
    platform?: string;
    target?: string;
    outputs?: string;
    inputStream?: Blob;
}

export interface ImageCreateRequest {
    xRegistryAuth?: string;
    fromImage?: string;
    fromSrc?: string;
    repo?: string;
    tag?: string;
    message?: string;
    platform?: string;
    inputImage?: Blob;
}

export interface ImageDeleteRequest {
    name: string;
    force?: boolean;
    noprune?: boolean;
}

export interface ImageGetRequest {
    name: string;
}

export interface ImageGetAllRequest {
    names: string;
}

export interface ImageHistoryRequest {
    name: string;
}

export interface ImageInspectRequest {
    name: string;
}

export interface ImageListRequest {
    all?: boolean;
    filters?: string;
    digests?: boolean;
}

export interface ImageLoadRequest {
    quiet?: boolean;
    request?: string;
}

export interface ImagePruneRequest {
    filters?: string;
}

export interface ImagePushRequest {
    name: string;
    tag?: string;
    all?: boolean;
    compress?: boolean;
    destination?: string;
    xRegistryAuth?: string;
}

export interface ImageSearchRequest {
    term?: string;
    limit?: number;
    filters?: string;
    tlsVerify?: boolean;
    listTags?: boolean;
}

export interface ImageTagRequest {
    name: string;
    repo?: string;
    tag?: string;
}

/**
 * 
 */
export class ImagesCompatApi extends runtime.BaseAPI {

    /**
     * Build an image from the given Dockerfile(s)
     * Create image
     */
    async imageBuildRaw(requestParameters: ImageBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageBuild200Response>> {
        const queryParameters: any = {};

        if (requestParameters['dockerfile'] != null) {
            queryParameters['dockerfile'] = requestParameters['dockerfile'];
        }

        if (requestParameters['t'] != null) {
            queryParameters['t'] = requestParameters['t'];
        }

        if (requestParameters['extrahosts'] != null) {
            queryParameters['extrahosts'] = requestParameters['extrahosts'];
        }

        if (requestParameters['remote'] != null) {
            queryParameters['remote'] = requestParameters['remote'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['nocache'] != null) {
            queryParameters['nocache'] = requestParameters['nocache'];
        }

        if (requestParameters['cachefrom'] != null) {
            queryParameters['cachefrom'] = requestParameters['cachefrom'];
        }

        if (requestParameters['pull'] != null) {
            queryParameters['pull'] = requestParameters['pull'];
        }

        if (requestParameters['rm'] != null) {
            queryParameters['rm'] = requestParameters['rm'];
        }

        if (requestParameters['forcerm'] != null) {
            queryParameters['forcerm'] = requestParameters['forcerm'];
        }

        if (requestParameters['memory'] != null) {
            queryParameters['memory'] = requestParameters['memory'];
        }

        if (requestParameters['memswap'] != null) {
            queryParameters['memswap'] = requestParameters['memswap'];
        }

        if (requestParameters['cpushares'] != null) {
            queryParameters['cpushares'] = requestParameters['cpushares'];
        }

        if (requestParameters['cpusetcpus'] != null) {
            queryParameters['cpusetcpus'] = requestParameters['cpusetcpus'];
        }

        if (requestParameters['cpuperiod'] != null) {
            queryParameters['cpuperiod'] = requestParameters['cpuperiod'];
        }

        if (requestParameters['cpuquota'] != null) {
            queryParameters['cpuquota'] = requestParameters['cpuquota'];
        }

        if (requestParameters['buildargs'] != null) {
            queryParameters['buildargs'] = requestParameters['buildargs'];
        }

        if (requestParameters['shmsize'] != null) {
            queryParameters['shmsize'] = requestParameters['shmsize'];
        }

        if (requestParameters['squash'] != null) {
            queryParameters['squash'] = requestParameters['squash'];
        }

        if (requestParameters['labels'] != null) {
            queryParameters['labels'] = requestParameters['labels'];
        }

        if (requestParameters['networkmode'] != null) {
            queryParameters['networkmode'] = requestParameters['networkmode'];
        }

        if (requestParameters['platform'] != null) {
            queryParameters['platform'] = requestParameters['platform'];
        }

        if (requestParameters['target'] != null) {
            queryParameters['target'] = requestParameters['target'];
        }

        if (requestParameters['outputs'] != null) {
            queryParameters['outputs'] = requestParameters['outputs'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['contentType'] != null) {
            headerParameters['Content-Type'] = String(requestParameters['contentType']);
        }

        if (requestParameters['xRegistryConfig'] != null) {
            headerParameters['X-Registry-Config'] = String(requestParameters['xRegistryConfig']);
        }

        const response = await this.request({
            path: `/build`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['inputStream'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageBuild200ResponseFromJSON(jsonValue));
    }

    /**
     * Build an image from the given Dockerfile(s)
     * Create image
     */
    async imageBuild(requestParameters: ImageBuildRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageBuild200Response> {
        const response = await this.imageBuildRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an image by either pulling it from a registry or importing it.
     * Create an image
     */
    async imageCreateRaw(requestParameters: ImageCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        if (requestParameters['fromImage'] != null) {
            queryParameters['fromImage'] = requestParameters['fromImage'];
        }

        if (requestParameters['fromSrc'] != null) {
            queryParameters['fromSrc'] = requestParameters['fromSrc'];
        }

        if (requestParameters['repo'] != null) {
            queryParameters['repo'] = requestParameters['repo'];
        }

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        if (requestParameters['message'] != null) {
            queryParameters['message'] = requestParameters['message'];
        }

        if (requestParameters['platform'] != null) {
            queryParameters['platform'] = requestParameters['platform'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'text/plain';

        if (requestParameters['xRegistryAuth'] != null) {
            headerParameters['X-Registry-Auth'] = String(requestParameters['xRegistryAuth']);
        }

        const response = await this.request({
            path: `/images/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['inputImage'] as any,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Create an image by either pulling it from a registry or importing it.
     * Create an image
     */
    async imageCreate(requestParameters: ImageCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.imageCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an image from local storage
     * Remove Image
     */
    async imageDeleteRaw(requestParameters: ImageDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ImageDelete200ResponseInner>>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        if (requestParameters['noprune'] != null) {
            queryParameters['noprune'] = requestParameters['noprune'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ImageDelete200ResponseInnerFromJSON));
    }

    /**
     * Delete an image from local storage
     * Remove Image
     */
    async imageDelete(requestParameters: ImageDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ImageDelete200ResponseInner>> {
        const response = await this.imageDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export an image in tarball format
     * Export an image
     */
    async imageGetRaw(requestParameters: ImageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/{name}/get`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Export an image in tarball format
     * Export an image
     */
    async imageGet(requestParameters: ImageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.imageGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a tarball containing all images and metadata for several image repositories
     * Export several images
     */
    async imageGetAllRaw(requestParameters: ImageGetAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['names'] == null) {
            throw new runtime.RequiredError(
                'names',
                'Required parameter "names" was null or undefined when calling imageGetAll().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['names'] != null) {
            queryParameters['names'] = requestParameters['names'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/get`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get a tarball containing all images and metadata for several image repositories
     * Export several images
     */
    async imageGetAll(requestParameters: ImageGetAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.imageGetAllRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return parent layers of an image.
     * History of an image
     */
    async imageHistoryRaw(requestParameters: ImageHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HistoryResponse>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageHistory().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/{name}/history`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HistoryResponseFromJSON(jsonValue));
    }

    /**
     * Return parent layers of an image.
     * History of an image
     */
    async imageHistory(requestParameters: ImageHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HistoryResponse> {
        const response = await this.imageHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return low-level information about an image.
     * Inspect an image
     */
    async imageInspectRaw(requestParameters: ImageInspectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageInspect>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageInspect().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/{name}/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageInspectFromJSON(jsonValue));
    }

    /**
     * Return low-level information about an image.
     * Inspect an image
     */
    async imageInspect(requestParameters: ImageInspectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageInspect> {
        const response = await this.imageInspectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
     * List Images
     */
    async imageListRaw(requestParameters: ImageListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Summary>>> {
        const queryParameters: any = {};

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        if (requestParameters['digests'] != null) {
            queryParameters['digests'] = requestParameters['digests'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SummaryFromJSON));
    }

    /**
     * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
     * List Images
     */
    async imageList(requestParameters: ImageListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Summary>> {
        const response = await this.imageListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load a set of images and tags into a repository.
     * Import image
     */
    async imageLoadRaw(requestParameters: ImageLoadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['quiet'] != null) {
            queryParameters['quiet'] = requestParameters['quiet'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/images/load`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Load a set of images and tags into a repository.
     * Import image
     */
    async imageLoad(requestParameters: ImageLoadRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageLoadRaw(requestParameters, initOverrides);
    }

    /**
     * Remove images from local storage that are not being used by a container
     * Prune unused images
     */
    async imagePruneRaw(requestParameters: ImagePruneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ImageDelete200ResponseInner>>> {
        const queryParameters: any = {};

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/prune`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ImageDelete200ResponseInnerFromJSON));
    }

    /**
     * Remove images from local storage that are not being used by a container
     * Prune unused images
     */
    async imagePrune(requestParameters: ImagePruneRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ImageDelete200ResponseInner>> {
        const response = await this.imagePruneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Push an image to a container registry
     * Push Image
     */
    async imagePushRaw(requestParameters: ImagePushRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imagePush().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        if (requestParameters['all'] != null) {
            queryParameters['all'] = requestParameters['all'];
        }

        if (requestParameters['compress'] != null) {
            queryParameters['compress'] = requestParameters['compress'];
        }

        if (requestParameters['destination'] != null) {
            queryParameters['destination'] = requestParameters['destination'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xRegistryAuth'] != null) {
            headerParameters['X-Registry-Auth'] = String(requestParameters['xRegistryAuth']);
        }

        const response = await this.request({
            path: `/images/{name}/push`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Push an image to a container registry
     * Push Image
     */
    async imagePush(requestParameters: ImagePushRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.imagePushRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search registries for an image
     * Search images
     */
    async imageSearchRaw(requestParameters: ImageSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageSearch200Response>> {
        const queryParameters: any = {};

        if (requestParameters['term'] != null) {
            queryParameters['term'] = requestParameters['term'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['filters'] != null) {
            queryParameters['filters'] = requestParameters['filters'];
        }

        if (requestParameters['tlsVerify'] != null) {
            queryParameters['tlsVerify'] = requestParameters['tlsVerify'];
        }

        if (requestParameters['listTags'] != null) {
            queryParameters['listTags'] = requestParameters['listTags'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageSearch200ResponseFromJSON(jsonValue));
    }

    /**
     * Search registries for an image
     * Search images
     */
    async imageSearch(requestParameters: ImageSearchRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageSearch200Response> {
        const response = await this.imageSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Tag an image so that it becomes part of a repository.
     * Tag an image
     */
    async imageTagRaw(requestParameters: ImageTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling imageTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['repo'] != null) {
            queryParameters['repo'] = requestParameters['repo'];
        }

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/images/{name}/tag`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Tag an image so that it becomes part of a repository.
     * Tag an image
     */
    async imageTag(requestParameters: ImageTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.imageTagRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ImageBuildContentTypeEnum = {
    ApplicationXTar: 'application/x-tar'
} as const;
export type ImageBuildContentTypeEnum = typeof ImageBuildContentTypeEnum[keyof typeof ImageBuildContentTypeEnum];
